#include "smt-switch/utils.h"
#include "frontend/btor2_encoder.h"
#include "utils/logger.h"
#include "framework/ts.h"
#include "smt-switch/boolector_factory.h"
#include "smt-switch/identity_walker.h"

#include <iostream>
#include <string>
#include <fstream>
#include <chrono>
#include <memory>
#include <vector>

using namespace wasim;
using namespace smt;
using namespace std;

class BtorPreprocessor {
private:
    SmtSolver solver_;
    TransitionSystem ts_;
    static constexpr size_t BUFFER_SIZE = 64 * 1024 * 1024;  // 64MB buffer
    
    // Write variable declarations
    void write_vars(ofstream& out, const UnorderedTermSet& vars, const string& type) {
        size_t count = 0;
        size_t total = vars.size();
        
        for (const Term& var : vars) {
            out << "(declare-fun |" << var->to_string() 
                << "| () " << var->get_sort()->to_string() << ")\n";
                
            if (++count % 100000 == 0) {  // Report progress every 100,000 variables
                cout << "Processed " << count << "/" << total << " " << type << "\n";
                out.flush();  // Periodic flush to avoid data accumulation
            }
        }
        if (count % 100000 != 0) {  // Final flush
            out.flush();
        }
    }

    // Write constraints
    void write_constraint(ofstream& out, const Term& constraint) {
        if (!constraint->is_value()) {
            out << "(assert " << constraint->to_string() << ")\n";
        }
    }

    // Write properties
    void write_properties(ofstream& out, const TermVec& props) {
        if (!props.empty()) {
            if (props.size() == 1) {
                out << "(assert (not " << props[0]->to_string() << "))\n";
            } else {
                out << "(assert (not (and";
                for (const Term& prop : props) {
                    out << " " << prop->to_string();
                }
                out << ")))\n";
            }
        }
    }

public:
    BtorPreprocessor() : 
        solver_(BoolectorSolverFactory::create(false)),
        ts_(solver_)
    {
        solver_->set_logic("QF_BV");
        solver_->set_opt("incremental", "true");
    }

    void preprocess(const string& input_file, const string& output_file) {
        // Get input file size for progress reporting
        ifstream in(input_file, ios::ate | ios::binary);
        if (!in.is_open()) {
            throw runtime_error("Cannot open input file: " + input_file);
        }
        size_t file_size = in.tellg();
        in.close();

        cout << "Processing BTOR2 file of size: " << file_size / (1024*1024) << "MB\n";
        
        // Parse BTOR2 file
        auto parse_start = chrono::steady_clock::now();
        cout << "Parsing BTOR2 file...\n";
        BTOR2Encoder encoder(input_file, ts_);
        auto parse_end = chrono::steady_clock::now();
        auto parse_duration = chrono::duration_cast<chrono::seconds>(parse_end - parse_start);
        cout << "Parsing completed in " << parse_duration.count() << " seconds.\n";

        // Generate SMT2 files
        cout << "Generating SMT2 files...\n";
        auto gen_start = chrono::steady_clock::now();

        // Get all bad properties
        const TermVec& props = ts_.prop();
        
        // Generate SMT2 file for each property
        for (size_t i = 0; i < props.size(); ++i) {
            // Construct output filename: insert property number before extension
            string prop_output_file = output_file;
            auto dot_pos = prop_output_file.find_last_of('.');
            if (dot_pos != string::npos) {
                prop_output_file.insert(dot_pos, "_prop" + to_string(i));
            } else {
                prop_output_file += "_prop" + to_string(i);
            }
            
            cout << "\nGenerating SMT2 file for property " << i << "...\n";
            TermVec single_prop = {props[i]};  // Only contains the current property
            dump_smt2(prop_output_file, single_prop);
        }

        auto gen_end = chrono::steady_clock::now();
        auto gen_duration = chrono::duration_cast<chrono::seconds>(gen_end - gen_start);
        cout << "SMT2 generation completed in " << gen_duration.count() << " seconds.\n";
    }

    void dump_smt2(const string& output_file, const TermVec& props_to_check) {
        ofstream out(output_file, ios::binary);
        if (!out.is_open()) {
            throw runtime_error("Cannot open output file: " + output_file);
        }
        
        // Set file buffer
        vector<char> buffer(BUFFER_SIZE);
        out.rdbuf()->pubsetbuf(buffer.data(), BUFFER_SIZE);

        // Write header
        out << ";; Generated by IDPV Btor2 Preprocessor\n(set-logic QF_BV)\n";

        // Write variable declarations
        cout << "Writing input variables...\n";
        write_vars(out, ts_.inputvars(), "input variables");

        cout << "Writing state variables...\n";
        write_vars(out, ts_.statevars(), "state variables");

        // Write initial state
        cout << "Writing initial state...\n";
        write_constraint(out, ts_.init());
        out.flush();

        // Write constraints
        cout << "Writing constraints...\n";
        size_t constraint_count = 0;
        size_t total_constraints = ts_.constraints().size();
        
        for (const auto& c : ts_.constraints()) {
            write_constraint(out, c.first);
            if (++constraint_count % 100000 == 0) {  // Report progress every 100,000 constraints
                cout << "Processed " << constraint_count << "/" << total_constraints << " constraints\n";
                out.flush();
            }
        }
        if (constraint_count % 100000 != 0) {  // Final flush
            out.flush();
        }

        // Write properties
        cout << "Writing properties...\n";
        write_properties(out, props_to_check);

        // Write footer
        out << "(check-sat)\n(exit)\n";
        out.flush();
        out.close();
        
        cout << "SMT2 file generation completed.\n";
    }
};

int main(int argc, char** argv) {
    if (argc != 3) {
        cerr << "Usage: " << argv[0] << " <input.btor2> <output.smt2>" << endl;
        return 1;
    }

    try {
        cout << "Starting BTOR2 to SMT2 conversion...\n";
        auto total_start = chrono::steady_clock::now();
        
        BtorPreprocessor preprocessor;
        preprocessor.preprocess(argv[1], argv[2]);
        
        auto total_end = chrono::steady_clock::now();
        auto total_duration = chrono::duration_cast<chrono::seconds>(total_end - total_start);
        cout << "Total conversion completed in " << total_duration.count() << " seconds.\n";
        return 0;
    }
    catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
}
