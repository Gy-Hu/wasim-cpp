#include "smt-switch/utils.h"
#include "frontend/btor2_encoder.h"
#include "utils/logger.h"
#include "framework/ts.h"
#include "smt-switch/boolector_factory.h"
#include "smt-switch/identity_walker.h"

#include <iostream>
#include <string>
#include <fstream>
#include <unordered_set>
#include <queue>

using namespace wasim;
using namespace smt;
using namespace std;

class ConeOfInfluence : public IdentityWalker
{
public:
    ConeOfInfluence(SmtSolver & solver) : IdentityWalker(solver, false) {}

    unordered_set<Term> get_cone(const Term & root) {
        // Create a non-const copy for visiting
        Term root_copy = root;
        visit(root_copy);
        return cone_;
    }

protected:
    WalkerStepResult visit_term(Term & term) override {
        if (cone_.find(term) != cone_.end()) {
            return Walker_Continue;
        }
        cone_.insert(term);
        return Walker_Continue;
    }

private:
    unordered_set<Term> cone_;
};

class BtorPreprocessor {
private:
    SmtSolver solver_;
    TransitionSystem ts_;
    unordered_set<Term> cone_vars_;
    
public:
    BtorPreprocessor(SmtSolver & solver) : solver_(solver), ts_(solver) {}

    void preprocess(const string & input_file, const string & output_file) {
        // parse btor2 file
        BTOR2Encoder encoder(input_file, ts_);

        // compute cone of influence starting from properties
        compute_cone_of_influence();

        // dump to smt2
        dump_smt2(output_file);
    }

private:
    void compute_cone_of_influence() {
        ConeOfInfluence coi(solver_);
        
        // Start from properties
        TermVec props = ts_.prop();
        for (const Term & prop : props) {
            auto prop_cone = coi.get_cone(prop);
            cone_vars_.insert(prop_cone.begin(), prop_cone.end());
        }

        // Include variables from transition relation that affect properties
        Term trans = ts_.trans();
        auto trans_cone = coi.get_cone(trans);
        cone_vars_.insert(trans_cone.begin(), trans_cone.end());

        // Include variables from initial state that affect properties
        Term init = ts_.init();
        auto init_cone = coi.get_cone(init);
        cone_vars_.insert(init_cone.begin(), init_cone.end());

        // Include variables from constraints
        for (const auto & c : ts_.constraints()) {
            auto constraint_cone = coi.get_cone(c.first);
            cone_vars_.insert(constraint_cone.begin(), constraint_cone.end());
        }
    }

    bool is_in_cone(const Term & var) const {
        return cone_vars_.find(var) != cone_vars_.end();
    }

    void dump_smt2(const string & output_file) {
        ofstream out(output_file);
        if (!out.is_open()) {
            throw runtime_error("Cannot open output file: " + output_file);
        }

        // write header
        out << ";; Generated by IDPV Btor2 Preprocessor" << endl;
        out << "(set-logic QF_BV)" << endl;

        // declare input variables in cone
        for (const Term & var : ts_.inputvars()) {
            if (is_in_cone(var)) {
                out << "(declare-fun " << var->to_string() 
                    << " () " << var->get_sort()->to_string() << ")" << endl;
            }
        }

        // declare state variables in cone
        for (const Term & var : ts_.statevars()) {
            if (is_in_cone(var)) {
                out << "(declare-fun " << var->to_string() 
                    << " () " << var->get_sort()->to_string() << ")" << endl;
            }
        }

        // write initial state constraints
        Term init = ts_.init();
        if (!init->is_value() || init != solver_->make_term(true)) {
            out << "(assert " << init->to_string() << ")" << endl;
        }

        // write transition system constraints
        Term trans = ts_.trans();
        if (!trans->is_value() || trans != solver_->make_term(true)) {
            out << "(assert " << trans->to_string() << ")" << endl;
        }

        // write constraints
        for (const auto & c : ts_.constraints()) {
            out << "(assert " << c.first->to_string() << ")" << endl;
        }

        // write property constraints - negate for bad properties
        TermVec props = ts_.prop();
        if (props.size() == 1) {
            out << "(assert (not " << props[0]->to_string() << "))" << endl;
        } else if (props.size() > 1) {
            out << "(assert (not (and";
            for (const Term & prop : props) {
                out << " " << prop->to_string();
            }
            out << ")))" << endl;
        }

        // end
        out << "(check-sat)" << endl;
        out << "(exit)" << endl;
        out.close();
    }
};

int main(int argc, char ** argv) {
    if (argc != 3) {
        cerr << "Usage: " << argv[0] << " <input.btor2> <output.smt2>" << endl;
        return 1;
    }

    try {
        SmtSolver solver = BoolectorSolverFactory::create(false);
        solver->set_logic("QF_BV");
        solver->set_opt("produce-models", "true");
        solver->set_opt("incremental", "true");
        BtorPreprocessor preprocessor(solver);
        preprocessor.preprocess(argv[1], argv[2]);
        cout << "Preprocessing completed successfully." << endl;
        return 0;
    }
    catch (const exception & e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
}
